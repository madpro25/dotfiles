var e,t,n=Object.defineProperty,r=Object.defineProperties,i=Object.getOwnPropertyDescriptors,a=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,u=(e,t,r)=>t in e?n(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,c=(e,t)=>{for(var n in t||(t={}))o.call(t,n)&&u(e,n,t[n]);if(a)for(var n of a(t))s.call(t,n)&&u(e,n,t[n]);return e},l=(e,t)=>r(e,i(t)),d=(e,t)=>{var n={};for(var r in e)o.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&a)for(var r of a(e))t.indexOf(r)<0&&s.call(e,r)&&(n[r]=e[r]);return n};(t=e||(e={})).uninitialized="uninitialized",t.pending="pending",t.fulfilled="fulfilled",t.rejected="rejected";var f=e=>[].concat(...e);import{isPlainObject as p}from"@reduxjs/toolkit";var m=p;function y(e,t){if(e===t||!(m(e)&&m(t)||Array.isArray(e)&&Array.isArray(t)))return t;const n=Object.keys(t),r=Object.keys(e);let i=n.length===r.length;const a=Array.isArray(t)?[]:{};for(const r of n)a[r]=y(e[r],t[r]),i&&(i=e[r]===a[r]);return i?e:a}import{isPlainObject as h}from"@reduxjs/toolkit";var g=(...e)=>fetch(...e),v=e=>e.status>=200&&e.status<=299,b=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function q(e){if(!h(e))return e;const t=c({},e);for(const[e,n]of Object.entries(t))void 0===n&&delete t[e];return t}function S(e={}){var t=e,{baseUrl:n,prepareHeaders:r=(e=>e),fetchFn:i=g,paramsSerializer:a,isJsonContentType:o=b,jsonContentType:s="application/json",timeout:u,validateStatus:f}=t,p=d(t,["baseUrl","prepareHeaders","fetchFn","paramsSerializer","isJsonContentType","jsonContentType","timeout","validateStatus"]);return"undefined"==typeof fetch&&i===g&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(e,t)=>{const{signal:y,getState:g,extra:b,endpoint:S,forced:O,type:R}=t;let T,w="string"==typeof e?{url:e}:e,{url:j,method:A="GET",headers:k=new Headers(p.headers),body:x,params:Q,responseHandler:I="json",validateStatus:C=(null!=f?f:v),timeout:P=u}=w,M=d(w,["url","method","headers","body","params","responseHandler","validateStatus","timeout"]),D=c(l(c({},p),{method:A,signal:y,body:x}),M);k=new Headers(q(k)),D.headers=await r(k,{getState:g,extra:b,endpoint:S,forced:O,type:R})||k;const N=e=>"object"==typeof e&&(h(e)||Array.isArray(e)||"function"==typeof e.toJSON);if(!D.headers.has("content-type")&&N(x)&&D.headers.set("content-type",s),N(x)&&o(D.headers)&&(D.body=JSON.stringify(x)),Q){const e=~j.indexOf("?")?"&":"?";j+=e+(a?a(Q):new URLSearchParams(q(Q)))}j=function(e,t){if(!e)return t;if(!t)return e;if(function(e){return new RegExp("(^|:)//").test(e)}(t))return t;const n=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=(e=>e.replace(/\/$/,""))(e),`${e}${n}${t=(e=>e.replace(/^\//,""))(t)}`}(n,j);const E=new Request(j,D);T={request:E.clone()};let K,F=!1,z=P&&setTimeout((()=>{F=!0,t.abort()}),P);try{K=await i(E)}catch(e){return{error:{status:F?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(e)},meta:T}}finally{z&&clearTimeout(z)}const _=K.clone();let $;T.response=_;let U="";try{let e;if(await Promise.all([m(K,I).then((e=>$=e),(t=>e=t)),_.text().then((e=>U=e),(()=>{}))]),e)throw e}catch(e){return{error:{status:"PARSING_ERROR",originalStatus:K.status,data:U,error:String(e)},meta:T}}return C(K,$)?{data:$,meta:T}:{error:{status:K.status,data:$},meta:T}};async function m(e,t){if("function"==typeof t)return t(e);if("content-type"===t&&(t=o(e.headers)?"json":"text"),"json"===t){const t=await e.text();return t.length?JSON.parse(t):null}return e.text()}}var O=class{constructor(e,t){this.value=e,this.meta=t}};async function R(e=0,t=5){const n=Math.min(e,t),r=~~((Math.random()+.4)*(300<<n));await new Promise((e=>setTimeout((t=>e(t)),r)))}var T={},w=Object.assign(((e,t)=>async(n,r,i)=>{const a=[5,(t||T).maxRetries,(i||T).maxRetries].filter((e=>void 0!==e)),[o]=a.slice(-1),s=c(c({maxRetries:o,backoff:R,retryCondition:(e,t,{attempt:n})=>n<=o},t),i);let u=0;for(;;)try{const t=await e(n,r,i);if(t.error)throw new O(t);return t}catch(e){if(u++,e.throwImmediately){if(e instanceof O)return e.value;throw e}if(e instanceof O&&!s.retryCondition(e.value.error,n,{attempt:u,baseQueryApi:r,extraOptions:i}))return e.value;await s.backoff(u,s.maxRetries)}}),{fail:function(e){throw Object.assign(new O({error:e}),{throwImmediately:!0})}});import{createAction as j}from"@reduxjs/toolkit";var A,k,x=j("__rtkq/focused"),Q=j("__rtkq/unfocused"),I=j("__rtkq/online"),C=j("__rtkq/offline"),P=!1;function M(e,t){return t?t(e,{onFocus:x,onFocusLost:Q,onOffline:C,onOnline:I}):function(){const t=()=>e(x()),n=()=>e(I()),r=()=>e(C()),i=()=>{"visible"===window.document.visibilityState?t():e(Q())};return P||"undefined"!=typeof window&&window.addEventListener&&(window.addEventListener("visibilitychange",i,!1),window.addEventListener("focus",t,!1),window.addEventListener("online",n,!1),window.addEventListener("offline",r,!1),P=!0),()=>{window.removeEventListener("focus",t),window.removeEventListener("visibilitychange",i),window.removeEventListener("online",n),window.removeEventListener("offline",r),P=!1}}()}import{createNextState as D,createSelector as N}from"@reduxjs/toolkit";function E(e){return e.type===A.query}function K(e,t,n,r,i,a){return"function"==typeof e?e(t,n,r,i).map(F).map(a):Array.isArray(e)?e.map(F).map(a):[]}function F(e){return"string"==typeof e?{type:e}:e}(k=A||(A={})).query="query",k.mutation="mutation";import{combineReducers as z,createAction as _,createSlice as $,isAnyOf as U,isFulfilled as L,isRejectedWithValue as W,createNextState as J,prepareAutoBatched as H}from"@reduxjs/toolkit";function B(e){return null!=e}var V=Symbol("forceQueryFn"),G=e=>"function"==typeof e[V];import{isAllOf as Y,isFulfilled as X,isPending as Z,isRejected as ee,isRejectedWithValue as te}from"@reduxjs/toolkit";import{isDraftable as ne,produceWithPatches as re}from"immer";import{createAsyncThunk as ie,SHOULD_AUTOBATCH as ae}from"@reduxjs/toolkit";function oe(e){return e}function se(e,t,n,r){return K(n[e.meta.arg.endpointName][t],X(e)?e.payload:void 0,te(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,r)}import{applyPatches as ue}from"immer";function ce(e,t,n){const r=e[t];r&&n(r)}function le(e){var t;return null!=(t="arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)?t:e.requestId}function de(e,t,n){const r=e[le(t)];r&&n(r)}var fe={},pe=Symbol.for("RTKQ/skipToken"),me=pe,ye={status:e.uninitialized},he=D(ye,(()=>{})),ge=D(ye,(()=>{}));import{isPlainObject as ve}from"@reduxjs/toolkit";var be=({endpointName:e,queryArgs:t})=>`${e}(${JSON.stringify(t,((e,t)=>ve(t)?Object.keys(t).sort().reduce(((e,n)=>(e[n]=t[n],e)),{}):t))})`;import{nanoid as qe}from"@reduxjs/toolkit";import{defaultMemoize as Se}from"reselect";function Oe(...e){return function(t){const n=Se((e=>{var n,r;return null==(r=t.extractRehydrationInfo)?void 0:r.call(t,e,{reducerPath:null!=(n=t.reducerPath)?n:"api"})})),r=l(c({reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1},t),{extractRehydrationInfo:n,serializeQueryArgs(e){let n=be;if("serializeQueryArgs"in e.endpointDefinition){const t=e.endpointDefinition.serializeQueryArgs;n=e=>{const n=t(e);return"string"==typeof n?n:be(l(c({},e),{queryArgs:n}))}}else t.serializeQueryArgs&&(n=t.serializeQueryArgs);return n(e)},tagTypes:[...t.tagTypes||[]]}),i={endpointDefinitions:{},batch(e){e()},apiUid:qe(),extractRehydrationInfo:n,hasRehydrationInfo:Se((e=>null!=n(e)))},a={injectEndpoints:function(e){const t=e.endpoints({query:e=>l(c({},e),{type:A.query}),mutation:e=>l(c({},e),{type:A.mutation})});for(const[n,r]of Object.entries(t))if(e.overrideExisting||!(n in i.endpointDefinitions)){i.endpointDefinitions[n]=r;for(const e of o)e.injectEndpoint(n,r)}return a},enhanceEndpoints({addTagTypes:e,endpoints:t}){if(e)for(const t of e)r.tagTypes.includes(t)||r.tagTypes.push(t);if(t)for(const[e,n]of Object.entries(t))"function"==typeof n?n(i.endpointDefinitions[e]):Object.assign(i.endpointDefinitions[e]||{},n);return a}},o=e.map((e=>e.init(a,r,i)));return a.injectEndpoints({endpoints:t.endpoints})}}function Re(){return function(){throw new Error("When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.")}}import{createAction as Te}from"@reduxjs/toolkit";var we=({reducerPath:e,api:t,context:n,internalState:r})=>{const{removeQueryResult:i,unsubscribeQueryResult:a}=t.internalActions;function o(e){const t=r.currentSubscriptions[e];return!!t&&!function(e){for(let t in e)return!1;return!0}(t)}const s={};function u(e,t,r,a){var u;const c=n.endpointDefinitions[t],l=null!=(u=null==c?void 0:c.keepUnusedDataFor)?u:a.keepUnusedDataFor;if(Infinity===l)return;const d=Math.max(0,Math.min(l,2147482.647));if(!o(e)){const t=s[e];t&&clearTimeout(t),s[e]=setTimeout((()=>{o(e)||r.dispatch(i({queryCacheKey:e})),delete s[e]}),1e3*d)}}return(r,i,o)=>{var c;if(a.match(r)){const t=i.getState()[e],{queryCacheKey:n}=r.payload;u(n,null==(c=t.queries[n])?void 0:c.endpointName,i,t.config)}if(t.util.resetApiState.match(r))for(const[e,t]of Object.entries(s))t&&clearTimeout(t),delete s[e];if(n.hasRehydrationInfo(r)){const t=i.getState()[e],{queries:a}=n.extractRehydrationInfo(r);for(const[e,n]of Object.entries(a))u(e,null==n?void 0:n.endpointName,i,t.config)}}};import{isAnyOf as je,isFulfilled as Ae,isRejectedWithValue as ke}from"@reduxjs/toolkit";var xe=({reducerPath:t,context:n,context:{endpointDefinitions:r},mutationThunk:i,api:a,assertTagType:o,refetchQuery:s})=>{const{removeQueryResult:u}=a.internalActions,c=je(Ae(i),ke(i));function l(r,i){const o=i.getState(),c=o[t],l=a.util.selectInvalidatedBy(o,r);n.batch((()=>{var t;const n=Array.from(l.values());for(const{queryCacheKey:r}of n){const n=c.queries[r],a=null!=(t=c.subscriptions[r])?t:{};n&&(0===Object.keys(a).length?i.dispatch(u({queryCacheKey:r})):n.status!==e.uninitialized&&i.dispatch(s(n,r)))}}))}return(e,t)=>{c(e)&&l(se(e,"invalidatesTags",r,o),t),a.util.invalidateTags.match(e)&&l(K(e.payload,void 0,void 0,void 0,void 0,o),t)}},Qe=({reducerPath:t,queryThunk:n,api:r,refetchQuery:i,internalState:a})=>{const o={};function s({queryCacheKey:n},r){const s=r.getState()[t].queries[n];if(!s||s.status===e.uninitialized)return;const u=l(a.currentSubscriptions[n]);if(!Number.isFinite(u))return;const c=o[n];(null==c?void 0:c.timeout)&&(clearTimeout(c.timeout),c.timeout=void 0);const d=Date.now()+u,f=o[n]={nextPollTimestamp:d,pollingInterval:u,timeout:setTimeout((()=>{f.timeout=void 0,r.dispatch(i(s,n))}),u)}}function u({queryCacheKey:n},r){const i=r.getState()[t].queries[n];if(!i||i.status===e.uninitialized)return;const u=l(a.currentSubscriptions[n]);if(!Number.isFinite(u))return void c(n);const d=o[n],f=Date.now()+u;(!d||f<d.nextPollTimestamp)&&s({queryCacheKey:n},r)}function c(e){const t=o[e];(null==t?void 0:t.timeout)&&clearTimeout(t.timeout),delete o[e]}function l(e={}){let t=Number.POSITIVE_INFINITY;for(let n in e)e[n].pollingInterval&&(t=Math.min(e[n].pollingInterval,t));return t}return(e,t)=>{(r.internalActions.updateSubscriptionOptions.match(e)||r.internalActions.unsubscribeQueryResult.match(e))&&u(e.payload,t),(n.pending.match(e)||n.rejected.match(e)&&e.meta.condition)&&u(e.meta.arg,t),(n.fulfilled.match(e)||n.rejected.match(e)&&!e.meta.condition)&&s(e.meta.arg,t),r.util.resetApiState.match(e)&&function(){for(const e of Object.keys(o))c(e)}()}};import{isAsyncThunkAction as Ie,isFulfilled as Ce}from"@reduxjs/toolkit";var Pe=new Error("Promise never resolved before cacheEntryRemoved."),Me=({api:e,reducerPath:t,context:n,queryThunk:r,mutationThunk:i})=>{const a=Ie(r),o=Ie(i),s=Ce(r,i),u={};function d(t,r,i,a,o){const s=n.endpointDefinitions[t],d=null==s?void 0:s.onCacheEntryAdded;if(!d)return;let f={};const p=new Promise((e=>{f.cacheEntryRemoved=e})),m=Promise.race([new Promise((e=>{f.valueResolved=e})),p.then((()=>{throw Pe}))]);m.catch((()=>{})),u[i]=f;const y=e.endpoints[t].select(s.type===A.query?r:i),h=a.dispatch(((e,t,n)=>n)),g=l(c({},a),{getCacheEntry:()=>y(a.getState()),requestId:o,extra:h,updateCachedData:s.type===A.query?n=>a.dispatch(e.util.updateQueryData(t,r,n)):void 0,cacheDataLoaded:m,cacheEntryRemoved:p}),v=d(r,g);Promise.resolve(v).catch((e=>{if(e!==Pe)throw e}))}return(n,c,l)=>{const f=function(t){return a(t)?t.meta.arg.queryCacheKey:o(t)?t.meta.requestId:e.internalActions.removeQueryResult.match(t)?t.payload.queryCacheKey:e.internalActions.removeMutationResult.match(t)?le(t.payload):""}(n);if(r.pending.match(n)){const e=l[t].queries[f],r=c.getState()[t].queries[f];!e&&r&&d(n.meta.arg.endpointName,n.meta.arg.originalArgs,f,c,n.meta.requestId)}else if(i.pending.match(n))c.getState()[t].mutations[f]&&d(n.meta.arg.endpointName,n.meta.arg.originalArgs,f,c,n.meta.requestId);else if(s(n)){const e=u[f];(null==e?void 0:e.valueResolved)&&(e.valueResolved({data:n.payload,meta:n.meta.baseQueryMeta}),delete e.valueResolved)}else if(e.internalActions.removeQueryResult.match(n)||e.internalActions.removeMutationResult.match(n)){const e=u[f];e&&(delete u[f],e.cacheEntryRemoved())}else if(e.util.resetApiState.match(n))for(const[e,t]of Object.entries(u))delete u[e],t.cacheEntryRemoved()}};import{isPending as De,isRejected as Ne,isFulfilled as Ee}from"@reduxjs/toolkit";var Ke,Fe=({api:e,context:t,queryThunk:n,mutationThunk:r})=>{const i=De(n,r),a=Ne(n,r),o=Ee(n,r),s={};return(n,r)=>{var u,d,f;if(i(n)){const{requestId:i,arg:{endpointName:a,originalArgs:o}}=n.meta,u=t.endpointDefinitions[a],d=null==u?void 0:u.onQueryStarted;if(d){const t={},n=new Promise(((e,n)=>{t.resolve=e,t.reject=n}));n.catch((()=>{})),s[i]=t;const f=e.endpoints[a].select(u.type===A.query?o:i),p=r.dispatch(((e,t,n)=>n)),m=l(c({},r),{getCacheEntry:()=>f(r.getState()),requestId:i,extra:p,updateCachedData:u.type===A.query?t=>r.dispatch(e.util.updateQueryData(a,o,t)):void 0,queryFulfilled:n});d(o,m)}}else if(o(n)){const{requestId:e,baseQueryMeta:t}=n.meta;null==(u=s[e])||u.resolve({data:n.payload,meta:t}),delete s[e]}else if(a(n)){const{requestId:e,rejectedWithValue:t,baseQueryMeta:r}=n.meta;null==(f=s[e])||f.reject({error:null!=(d=n.payload)?d:n.error,isUnhandledError:!t,meta:r}),delete s[e]}}},ze=({api:e,context:{apiUid:t}})=>(n,r)=>{e.util.resetApiState.match(n)&&r.dispatch(e.internalActions.middlewareRegistered(t))};import{produceWithPatches as _e}from"immer";var $e="function"==typeof queueMicrotask?queueMicrotask.bind("undefined"!=typeof window?window:"undefined"!=typeof global?global:globalThis):e=>(Ke||(Ke=Promise.resolve())).then(e).catch((e=>setTimeout((()=>{throw e}),0)));function Ue(e,...t){Object.assign(e,...t)}import{enablePatches as Le}from"immer";var We=Symbol(),Je=()=>({name:We,init(t,{baseQuery:n,reducerPath:r,serializeQueryArgs:i,keepUnusedDataFor:a,refetchOnMountOrArgChange:o,refetchOnFocus:s,refetchOnReconnect:u},d){Le();const p=e=>e;Object.assign(t,{reducerPath:r,endpoints:{},internalActions:{onOnline:I,onOffline:C,onFocus:x,onFocusLost:Q},util:{}});const{queryThunk:m,mutationThunk:h,patchQueryData:g,updateQueryData:v,upsertQueryData:b,prefetch:q,buildMatchThunkActions:S}=function({reducerPath:t,baseQuery:n,context:{endpointDefinitions:r},serializeQueryArgs:i,api:a}){const o=async(e,{signal:t,abort:i,rejectWithValue:a,fulfillWithValue:o,dispatch:u,getState:c,extra:l})=>{const d=r[e.endpointName];try{let r,a=oe;const f={signal:t,abort:i,dispatch:u,getState:c,extra:l,endpoint:e.endpointName,type:e.type,forced:"query"===e.type?s(e,c()):void 0},p="query"===e.type?e[V]:void 0;if(p?r=p():d.query?(r=await n(d.query(e.originalArgs),f,d.extraOptions),d.transformResponse&&(a=d.transformResponse)):r=await d.queryFn(e.originalArgs,f,d.extraOptions,(e=>n(e,f,d.extraOptions))),r.error)throw new O(r.error,r.meta);return o(await a(r.data,r.meta,e.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:r.meta,[ae]:!0})}catch(t){let n=t;if(n instanceof O){let t=oe;d.query&&d.transformErrorResponse&&(t=d.transformErrorResponse);try{return a(await t(n.value,n.meta,e.originalArgs),{baseQueryMeta:n.meta,[ae]:!0})}catch(e){n=e}}throw console.error(n),n}};function s(e,n){var r,i,a,o;const s=null==(i=null==(r=n[t])?void 0:r.queries)?void 0:i[e.queryCacheKey],u=null==(a=n[t])?void 0:a.config.refetchOnMountOrArgChange,c=null==s?void 0:s.fulfilledTimeStamp,l=null!=(o=e.forceRefetch)?o:e.subscribe&&u;return!!l&&(!0===l||(Number(new Date)-Number(c))/1e3>=l)}function u(e){return t=>{var n,r;return(null==(r=null==(n=null==t?void 0:t.meta)?void 0:n.arg)?void 0:r.endpointName)===e}}return{queryThunk:ie(`${t}/executeQuery`,o,{getPendingMeta:()=>({startedTimeStamp:Date.now(),[ae]:!0}),condition(e,{getState:n}){var i,a,o;const u=n(),c=null==(a=null==(i=u[t])?void 0:i.queries)?void 0:a[e.queryCacheKey],l=null==c?void 0:c.fulfilledTimeStamp,d=e.originalArgs,f=null==c?void 0:c.originalArgs,p=r[e.endpointName];return!(!G(e)&&("pending"===(null==c?void 0:c.status)||!s(e,u)&&(!E(p)||!(null==(o=null==p?void 0:p.forceRefetch)?void 0:o.call(p,{currentArg:d,previousArg:f,endpointState:c,state:u})))&&l))},dispatchConditionRejection:!0}),mutationThunk:ie(`${t}/executeMutation`,o,{getPendingMeta:()=>({startedTimeStamp:Date.now(),[ae]:!0})}),prefetch:(e,t,n)=>(r,i)=>{const o=(e=>"force"in e)(n)&&n.force,s=(e=>"ifOlderThan"in e)(n)&&n.ifOlderThan,u=(n=!0)=>a.endpoints[e].initiate(t,{forceRefetch:n}),c=a.endpoints[e].select(t)(i());if(o)r(u());else if(s){const e=null==c?void 0:c.fulfilledTimeStamp;if(!e)return void r(u());(Number(new Date)-Number(new Date(e)))/1e3>=s&&r(u())}else r(u(!1))},updateQueryData:(t,n,r)=>(i,o)=>{const s=a.endpoints[t].select(n)(o());let u={patches:[],inversePatches:[],undo:()=>i(a.util.patchQueryData(t,n,u.inversePatches))};if(s.status===e.uninitialized)return u;if("data"in s)if(ne(s.data)){const[,e,t]=re(s.data,r);u.patches.push(...e),u.inversePatches.push(...t)}else{const e=r(s.data);u.patches.push({op:"replace",path:[],value:e}),u.inversePatches.push({op:"replace",path:[],value:s.data})}return i(a.util.patchQueryData(t,n,u.patches)),u},upsertQueryData:(e,t,n)=>r=>r(a.endpoints[e].initiate(t,{subscribe:!1,forceRefetch:!0,[V]:()=>({data:n})})),patchQueryData:(e,t,n)=>o=>{o(a.internalActions.queryResultPatched({queryCacheKey:i({queryArgs:t,endpointDefinition:r[e],endpointName:e}),patches:n}))},buildMatchThunkActions:function(e,t){return{matchPending:Y(Z(e),u(t)),matchFulfilled:Y(X(e),u(t)),matchRejected:Y(ee(e),u(t))}}}}({baseQuery:n,reducerPath:r,context:d,api:t,serializeQueryArgs:i}),{reducer:R,actions:T}=function({reducerPath:t,queryThunk:n,mutationThunk:r,context:{endpointDefinitions:i,apiUid:a,extractRehydrationInfo:o,hasRehydrationInfo:s},assertTagType:u,config:d}){const f=_(`${t}/resetApiState`),p=$({name:`${t}/queries`,initialState:fe,reducers:{removeQueryResult:{reducer(e,{payload:{queryCacheKey:t}}){delete e[t]},prepare:H()},queryResultPatched(e,{payload:{queryCacheKey:t,patches:n}}){ce(e,t,(e=>{e.data=ue(e.data,n.concat())}))}},extraReducers(t){t.addCase(n.pending,((t,{meta:n,meta:{arg:r}})=>{var i;const a=G(r);(r.subscribe||a)&&(null!=t[i=r.queryCacheKey]||(t[i]={status:e.uninitialized,endpointName:r.endpointName})),ce(t,r.queryCacheKey,(t=>{t.status=e.pending,t.requestId=a&&t.requestId?t.requestId:n.requestId,void 0!==r.originalArgs&&(t.originalArgs=r.originalArgs),t.startedTimeStamp=n.startedTimeStamp}))})).addCase(n.fulfilled,((t,{meta:n,payload:r})=>{ce(t,n.arg.queryCacheKey,(t=>{var a;if(t.requestId!==n.requestId&&!G(n.arg))return;const{merge:o}=i[n.arg.endpointName];if(t.status=e.fulfilled,o)if(void 0!==t.data){const{fulfilledTimeStamp:e,arg:i,baseQueryMeta:a,requestId:s}=n;let u=J(t.data,(t=>o(t,r,{arg:i.originalArgs,baseQueryMeta:a,fulfilledTimeStamp:e,requestId:s})));t.data=u}else t.data=r;else t.data=null==(a=i[n.arg.endpointName].structuralSharing)||a?y(t.data,r):r;delete t.error,t.fulfilledTimeStamp=n.fulfilledTimeStamp}))})).addCase(n.rejected,((t,{meta:{condition:n,arg:r,requestId:i},error:a,payload:o})=>{ce(t,r.queryCacheKey,(t=>{if(n);else{if(t.requestId!==i)return;t.status=e.rejected,t.error=null!=o?o:a}}))})).addMatcher(s,((t,n)=>{const{queries:r}=o(n);for(const[n,i]of Object.entries(r))(null==i?void 0:i.status)!==e.fulfilled&&(null==i?void 0:i.status)!==e.rejected||(t[n]=i)}))}}),m=$({name:`${t}/mutations`,initialState:fe,reducers:{removeMutationResult:{reducer(e,{payload:t}){const n=le(t);n in e&&delete e[n]},prepare:H()}},extraReducers(t){t.addCase(r.pending,((t,{meta:n,meta:{requestId:r,arg:i,startedTimeStamp:a}})=>{i.track&&(t[le(n)]={requestId:r,status:e.pending,endpointName:i.endpointName,startedTimeStamp:a})})).addCase(r.fulfilled,((t,{payload:n,meta:r})=>{r.arg.track&&de(t,r,(t=>{t.requestId===r.requestId&&(t.status=e.fulfilled,t.data=n,t.fulfilledTimeStamp=r.fulfilledTimeStamp)}))})).addCase(r.rejected,((t,{payload:n,error:r,meta:i})=>{i.arg.track&&de(t,i,(t=>{t.requestId===i.requestId&&(t.status=e.rejected,t.error=null!=n?n:r)}))})).addMatcher(s,((t,n)=>{const{mutations:r}=o(n);for(const[n,i]of Object.entries(r))(null==i?void 0:i.status)!==e.fulfilled&&(null==i?void 0:i.status)!==e.rejected||n===(null==i?void 0:i.requestId)||(t[n]=i)}))}}),h=$({name:`${t}/invalidation`,initialState:fe,reducers:{},extraReducers(e){e.addCase(p.actions.removeQueryResult,((e,{payload:{queryCacheKey:t}})=>{for(const n of Object.values(e))for(const e of Object.values(n)){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}})).addMatcher(s,((e,t)=>{var n,r,i,a;const{provided:s}=o(t);for(const[t,o]of Object.entries(s))for(const[s,u]of Object.entries(o)){const o=null!=(a=(r=null!=(n=e[t])?n:e[t]={})[i=s||"__internal_without_id"])?a:r[i]=[];for(const e of u)o.includes(e)||o.push(e)}})).addMatcher(U(L(n),W(n)),((e,t)=>{var n,r,a,o;const s=se(t,"providesTags",i,u),{queryCacheKey:c}=t.meta.arg;for(const t of Object.values(e))for(const e of Object.values(t)){const t=e.indexOf(c);-1!==t&&e.splice(t,1)}for(const{type:t,id:i}of s){const s=null!=(o=(r=null!=(n=e[t])?n:e[t]={})[a=i||"__internal_without_id"])?o:r[a]=[];s.includes(c)||s.push(c)}}))}}),g=$({name:`${t}/subscriptions`,initialState:fe,reducers:{updateSubscriptionOptions(e,t){},unsubscribeQueryResult(e,t){},internal_probeSubscription(e,t){}}}),v=$({name:`${t}/internalSubscriptions`,initialState:fe,reducers:{subscriptionsUpdated:(e,t)=>ue(e,t.payload)}}),b=$({name:`${t}/config`,initialState:c({online:"undefined"==typeof navigator||void 0===navigator.onLine||navigator.onLine,focused:"undefined"==typeof document||"hidden"!==document.visibilityState,middlewareRegistered:!1},d),reducers:{middlewareRegistered(e,{payload:t}){e.middlewareRegistered="conflict"!==e.middlewareRegistered&&a===t||"conflict"}},extraReducers:e=>{e.addCase(I,(e=>{e.online=!0})).addCase(C,(e=>{e.online=!1})).addCase(x,(e=>{e.focused=!0})).addCase(Q,(e=>{e.focused=!1})).addMatcher(s,(e=>c({},e)))}}),q=z({queries:p.reducer,mutations:m.reducer,provided:h.reducer,subscriptions:v.reducer,config:b.reducer});return{reducer:(e,t)=>q(f.match(t)?void 0:e,t),actions:l(c(c(c(c(c({},b.actions),p.actions),g.actions),v.actions),m.actions),{unsubscribeMutationResult:m.actions.removeMutationResult,resetApiState:f})}}({context:d,queryThunk:m,mutationThunk:h,reducerPath:r,assertTagType:p,config:{refetchOnFocus:s,refetchOnReconnect:u,refetchOnMountOrArgChange:o,keepUnusedDataFor:a,reducerPath:r}});Ue(t.util,{patchQueryData:g,updateQueryData:v,upsertQueryData:b,prefetch:q,resetApiState:T.resetApiState}),Ue(t.internalActions,T);const{middleware:w,actions:j}=function(t){const{reducerPath:n,queryThunk:r,api:i,context:a}=t,{apiUid:o}=a,s={invalidateTags:Te(`${n}/invalidateTags`)},u=[ze,we,xe,Qe,Me,Fe];return{middleware:r=>{let s=!1;const f=l(c({},t),{internalState:{currentSubscriptions:{}},refetchQuery:d}),p=u.map((e=>e(f))),m=(({api:e,queryThunk:t,internalState:n})=>{const r=`${e.reducerPath}/subscriptions`;let i=null,a=!1;const{updateSubscriptionOptions:o,unsubscribeQueryResult:s}=e.internalActions;return(u,c)=>{var l,d;if(i||(i=JSON.parse(JSON.stringify(n.currentSubscriptions))),e.internalActions.internal_probeSubscription.match(u)){const{queryCacheKey:e,requestId:t}=u.payload;return[!1,!!(null==(l=n.currentSubscriptions[e])?void 0:l[t])]}const f=((n,r)=>{var i,a,u,c,l,d,f,p,m;if(o.match(r)){const{queryCacheKey:e,requestId:t,options:a}=r.payload;return(null==(i=null==n?void 0:n[e])?void 0:i[t])&&(n[e][t]=a),!0}if(s.match(r)){const{queryCacheKey:e,requestId:t}=r.payload;return n[e]&&delete n[e][t],!0}if(e.internalActions.removeQueryResult.match(r))return delete n[r.payload.queryCacheKey],!0;if(t.pending.match(r)){const{meta:{arg:e,requestId:t}}=r;if(e.subscribe){const r=null!=(u=n[a=e.queryCacheKey])?u:n[a]={};return r[t]=null!=(l=null!=(c=e.subscriptionOptions)?c:r[t])?l:{},!0}}if(t.rejected.match(r)){const{meta:{condition:e,arg:t,requestId:i}}=r;if(e&&t.subscribe){const e=null!=(f=n[d=t.queryCacheKey])?f:n[d]={};return e[i]=null!=(m=null!=(p=t.subscriptionOptions)?p:e[i])?m:{},!0}}return!1})(n.currentSubscriptions,u);if(f){a||($e((()=>{const t=JSON.parse(JSON.stringify(n.currentSubscriptions)),[,r]=_e(i,(()=>t));c.next(e.internalActions.subscriptionsUpdated(r)),i=t,a=!1})),a=!0);const o=!!(null==(d=u.type)?void 0:d.startsWith(r)),s=t.rejected.match(u)&&u.meta.condition&&!!u.meta.arg.subscribe;return[!o&&!s,!1]}return[!0,!1]}})(f),y=(({reducerPath:t,context:n,api:r,refetchQuery:i,internalState:a})=>{const{removeQueryResult:o}=r.internalActions;function s(r,s){const u=r.getState()[t],c=u.queries,l=a.currentSubscriptions;n.batch((()=>{for(const t of Object.keys(l)){const n=c[t],a=l[t];a&&n&&(Object.values(a).some((e=>!0===e[s]))||Object.values(a).every((e=>void 0===e[s]))&&u.config[s])&&(0===Object.keys(a).length?r.dispatch(o({queryCacheKey:t})):n.status!==e.uninitialized&&r.dispatch(i(n,t)))}}))}return(e,t)=>{x.match(e)&&s(t,"refetchOnFocus"),I.match(e)&&s(t,"refetchOnReconnect")}})(f);return e=>t=>{s||(s=!0,r.dispatch(i.internalActions.middlewareRegistered(o)));const u=l(c({},r),{next:e}),d=r.getState(),[f,h]=m(t,u,d);let g;if(g=f?e(t):h,r.getState()[n]&&(y(t,u,d),(e=>!!e&&"string"==typeof e.type&&e.type.startsWith(`${n}/`))(t)||a.hasRehydrationInfo(t)))for(let e of p)e(t,u,d);return g}},actions:s};function d(e,t,n={}){return r(c({type:"query",endpointName:e.endpointName,originalArgs:e.originalArgs,subscribe:!1,forceRefetch:!0,queryCacheKey:t},n))}}({reducerPath:r,context:d,queryThunk:m,mutationThunk:h,api:t,assertTagType:p});Ue(t.util,j),Ue(t,{reducer:R,middleware:w});const{buildQuerySelector:k,buildMutationSelector:P,selectInvalidatedBy:M}=function({serializeQueryArgs:t,reducerPath:n}){const r=e=>he,i=e=>ge;return{buildQuerySelector:function(e,n){return i=>{const s=t({queryArgs:i,endpointDefinition:n,endpointName:e});return N(i===pe?r:e=>{var t,n,r;return null!=(r=null==(n=null==(t=o(e))?void 0:t.queries)?void 0:n[s])?r:he},a)}},buildMutationSelector:function(){return e=>{var t;let n;return n="object"==typeof e?null!=(t=le(e))?t:pe:e,N(n===pe?i:e=>{var t,r,i;return null!=(i=null==(r=null==(t=o(e))?void 0:t.mutations)?void 0:r[n])?i:ge},a)}},selectInvalidatedBy:function(e,t){var r;const i=e[n],a=new Set;for(const e of t.map(F)){const t=i.provided[e.type];if(!t)continue;let n=null!=(r=void 0!==e.id?t[e.id]:f(Object.values(t)))?r:[];for(const e of n)a.add(e)}return f(Array.from(a.values()).map((e=>{const t=i.queries[e];return t?[{queryCacheKey:e,endpointName:t.endpointName,originalArgs:t.originalArgs}]:[]})))}};function a(t){return c(c({},t),{status:n=t.status,isUninitialized:n===e.uninitialized,isLoading:n===e.pending,isSuccess:n===e.fulfilled,isError:n===e.rejected});var n}function o(e){return e[n]}}({serializeQueryArgs:i,reducerPath:r});Ue(t.util,{selectInvalidatedBy:M});const{buildInitiateQuery:D,buildInitiateMutation:K,getRunningMutationThunk:te,getRunningMutationsThunk:me,getRunningQueriesThunk:ye,getRunningQueryThunk:ve,getRunningOperationPromises:be,removalWarning:qe}=function({serializeQueryArgs:e,queryThunk:t,mutationThunk:n,api:r,context:i}){const a=new Map,o=new Map,{unsubscribeQueryResult:s,removeMutationResult:u,updateSubscriptionOptions:c}=r.internalActions;return{buildInitiateQuery:function(n,i){const o=(u,{subscribe:l=!0,forceRefetch:d,subscriptionOptions:f,[V]:p}={})=>(m,y)=>{var h;const g=e({queryArgs:u,endpointDefinition:i,endpointName:n}),v=t({type:"query",subscribe:l,forceRefetch:d,subscriptionOptions:f,endpointName:n,originalArgs:u,queryCacheKey:g,[V]:p}),b=r.endpoints[n].select(u),q=m(v),S=b(y()),{requestId:O,abort:R}=q,T=S.requestId!==O,w=null==(h=a.get(m))?void 0:h[g],j=()=>b(y()),A=Object.assign(p?q.then(j):T&&!w?Promise.resolve(S):Promise.all([w,q]).then(j),{arg:u,requestId:O,subscriptionOptions:f,queryCacheKey:g,abort:R,async unwrap(){const e=await A;if(e.isError)throw e.error;return e.data},refetch:()=>m(o(u,{subscribe:!1,forceRefetch:!0})),unsubscribe(){l&&m(s({queryCacheKey:g,requestId:O}))},updateSubscriptionOptions(e){A.subscriptionOptions=e,m(c({endpointName:n,requestId:O,queryCacheKey:g,options:e}))}});if(!w&&!T&&!p){const e=a.get(m)||{};e[g]=A,a.set(m,e),A.then((()=>{delete e[g],Object.keys(e).length||a.delete(m)}))}return A};return o},buildInitiateMutation:function(e){return(t,{track:r=!0,fixedCacheKey:i}={})=>(a,s)=>{const c=n({type:"mutation",endpointName:e,originalArgs:t,track:r,fixedCacheKey:i}),l=a(c),{requestId:d,abort:f,unwrap:p}=l,m=l.unwrap().then((e=>({data:e}))).catch((e=>({error:e}))),y=()=>{a(u({requestId:d,fixedCacheKey:i}))},h=Object.assign(m,{arg:l.arg,requestId:d,abort:f,unwrap:p,unsubscribe:y,reset:y}),g=o.get(a)||{};return o.set(a,g),g[d]=h,h.then((()=>{delete g[d],Object.keys(g).length||o.delete(a)})),i&&(g[i]=h,h.then((()=>{g[i]===h&&(delete g[i],Object.keys(g).length||o.delete(a))}))),h}},getRunningQueryThunk:function(t,n){return r=>{var o;const s=e({queryArgs:n,endpointDefinition:i.endpointDefinitions[t],endpointName:t});return null==(o=a.get(r))?void 0:o[s]}},getRunningMutationThunk:function(e,t){return e=>{var n;return null==(n=o.get(e))?void 0:n[t]}},getRunningQueriesThunk:function(){return e=>Object.values(a.get(e)||{}).filter(B)},getRunningMutationsThunk:function(){return e=>Object.values(o.get(e)||{}).filter(B)},getRunningOperationPromises:function(){{const e=e=>Array.from(e.values()).flatMap((e=>e?Object.values(e):[]));return[...e(a),...e(o)].filter(B)}},removalWarning:function(){throw new Error("This method had to be removed due to a conceptual bug in RTK.\n       Please see https://github.com/reduxjs/redux-toolkit/pull/2481 for details.\n       See https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering for new guidance on SSR.")}}}({queryThunk:m,mutationThunk:h,api:t,serializeQueryArgs:i,context:d});return Ue(t.util,{getRunningOperationPromises:be,getRunningOperationPromise:qe,getRunningMutationThunk:te,getRunningMutationsThunk:me,getRunningQueryThunk:ve,getRunningQueriesThunk:ye}),{name:We,injectEndpoint(e,n){var r;const i=t;null!=(r=i.endpoints)[e]||(r[e]={}),E(n)?Ue(i.endpoints[e],{name:e,select:k(e,n),initiate:D(e,n)},S(m,e)):n.type===A.mutation&&Ue(i.endpoints[e],{name:e,select:P(),initiate:K(e)},S(h,e))}}}}),He=Oe(Je());export{e as QueryStatus,Oe as buildCreateApi,y as copyWithStructuralSharing,Je as coreModule,He as createApi,be as defaultSerializeQueryArgs,Re as fakeBaseQuery,S as fetchBaseQuery,w as retry,M as setupListeners,me as skipSelector,pe as skipToken};
//# sourceMappingURL=rtk-query.modern.production.min.js.map